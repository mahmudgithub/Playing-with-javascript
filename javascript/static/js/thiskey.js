// link:https://js.zonayed.me/advance/post-0 
//কয়েকবার প্র্যাকটিস করার পর, রুলসগুলো জানার পর আস্তে আস্তে thisকীওয়ার্ডটা পুরোপুরি ধরতে পারবেন।
// thisজাভাস্ক্রিপ্ট এ একটা রিসার্ভড কীওয়ার্ড, মানে এই নামটা আর কোনো ভ্যারিয়েবল বা ফাংশনের জন্যে ইউজ
//  করতে পারবেন না। আর এই thisঅনেকভাবে অনেকরকম জায়গায় ব্যবহার করা হয়। তাই আপনি যে প্রথমদিকেই
//   সবজায়গায় বুঝে ফেলবেন thisটা আসলে কি ব্যাপারটা এরকম নয়। কিন্তু যদি ব্যাসিক রুলসগুলো জানা থাকে
//    thisকিভাবে কাজ করে তাহলে আশা করি আরো বড়, জটিল কোডেও আপনার বুঝতে বেশী টাইম লাগবে না।
// সাধারণত একটা ফাংশনকে কিভাবে কল করা হচ্ছে সেটার উপর ভিত্তি করে thisএর ভ্যালু ডিটারমাইন করা হয়। 
// আর এটার ভ্যালু ডিটারমাইন করা হয় এক্সিকিউশনের সময়।



//যেগুলো দিয়ে thisএর ভ্যালু ডিটারমাইন করা যাবেঃ********************
// ১। গ্লোবাল রুলস
// ২। অবজেক্ট রুলস
// ৩। স্পষ্ট রুলস
// ৪। newকীওয়ার্ড রুলস
// আমার এখানে বলা রুলসগুলো অফিশিয়ালভাবে কোথাও বলা নেই, কিন্তু thisকীওয়ার্ড বুঝতে 
// এই রুলসগুলো বেশ কাজে লাগে তাই আমি এভাবে লিখেছি…



// গ্লোবাল রুলসঃ ***************************************************
// //যদি আপনি thisকীওয়ার্ড যেকোনো জায়গায় ইউজ করেন, আপনার কাস্টমভাবে ডিফাইন করা কোনো অবজেক্ট 
// //এর ভিতরে ছাড়া, তাহলে সেটা সবসময় আপনার গ্লোবাল অবজেক্টকে ইন্ডিকেট করবে।
// //সেইমভাবে যদি আমাদের কোনো ডিফাইন করা ফাংশনের ভিতরেও thisইউজ করি,
// // তাহলে সেটার ভ্যালু কি হবে সেটা সম্পূর্ণ ডিপেন্ড করবে আপনি উক্ত ফাংশনটাকে কিভাবে কল করছেন সেটার উপর।
// fn=()=>{
//   this.names='mahmud';
//    var city='rajshhsi';
//     console.log(names);
//     console.log(city);
// } 
// fn()
// console.log(names);
// console.log(city);
// //on the above exampele show tis.names behave as a global variable and city show local 
// //so names parameter call locally and globaly but city call only locally
// //কারণটা কি? হ্যাঁ কারণ হচ্ছে আপনি যখন ফাংশন এর ভিতরে this.namesলিখলেন এবং সেই ফাংশনটা 
// //গ্লোবাল কন্টেক্সট এ কল করলেন তখন এই this.nameআসলে গ্লোবাল অবজেক্ট এর আন্ডারে nameএ 
// //অ্যাসাইন(window.name) হয়ে যাচ্ছে। তাই সিম্পলি আপনি এটা বাইরে যেকোনো জায়গায় অ্যাক্সেস পাচ্ছেন।
// // ‘strict mode’ এ এটা কাজ করবে না।



//অবজেক্ট রুলসঃ *************************************************************
// // এখন কাস্টমভাবে কোনো অবজেক্ট ডিফাইন করে সেটার ভিতর thisকীওয়ার্ড ইউজ করলে সেটার ভ্যালু 
// //আর গ্লোবাল অবজেক্টকে ইন্ডিকেট করবে না। এখানে এটার ভ্যালু চেঞ্জ হয়ে যাবে।
// const obj={
//     names:'mahmud',
//     city:'raj',
//     names:'hossain',
//     obj2:function(){console.log(this.names);}
// }
// obj.obj2()
// //তাহলে এবার ভাবেন তো এখানে ফাংশনের ভিতরের console.logএ this.nameকাকে ইন্ডিকেট করবে?
// // প্রথম রুলস(গ্লোবাল রুলস) এ এটা পড়বে না, কারণ এটা একটা কাস্টমভাবে ডিফাইনকৃত অবজেক্ট এর 
// //ভিতরে রয়েছে। এখানে দ্বিতীয় রুলস(অবজেক্ট রুলস) অনুযায়ী এটা কাছের কাস্টমভাবে ডিফাইনকৃত অবজেক্ট
// // কেই ইন্ডিকেট করবেঃ




// //এখন অবজেক্ট এর ভিতরে যদি আরেকটা অবজেক্ট থাকে আর সেখানে thisইউজ করা হয় তাহলে কি হবে?
// const obj1={
//     names:"mahmdu",
//     city:'raj',
//     names:'haossain',
//     oth:{
//         names:'lamyaa',
//         roll:12345,
//         fn:function(){
//             console.log(this.names);
//         }
//     }
// }
// obj1.oth.fn();
// //thisকীওয়ার্ডের ভ্যালু ডিটারমাইন করা হয় কাছের অবজেক্টটাকে দেখে। এখানে কাছের অবজেক্ট anotherObj,
// // তাই এখানে this.nameanotherObjএর nameটাকেই ইন্ডিকেট করবেঃ






//স্পষ্ট রুলসঃ*********************************************************
// // আপনারা হয়তো call, bind, applyমেথডের কথা শুনেছেন।এগুলোই আসলে স্পষ্টভাবে thisকীওয়ার্ডের ভ্যালু 
// //সেট করতে ইউজ করা হয়। কোথাও যদি দেখেন এগুলো ইউজ হয়েছে তাহলে খুব সহজেই সেখানে thisকীওয়ার্ড 
// //কাকে ইন্ডিকেট করছে সেটা ধরে ফেলতে পারবেন। কারণ এই call, bind, applyমেথডগুলো ইউজ করে প্রথম 
// //প্যারামিটারেই thisকীওয়ার্ড কাকে ইন্ডিকেট করবে সেটা সেট করা যায়। 
//call method*****************************
// var obj1={
//     names:'mahmud',
//     city:'raj',
//     obj2:{
//         names:'hossain',
//         roll:12345,
//         fn:function(){
//             console.log(this.names);
//         }
//     }
// }
// obj1.obj2.fn()
// //মানে এখানে Obj2 কে ইন্ডিকেট করছে। কিন্তু আমরা যদি কাস্টমভাবে বলে দিতে চাই Obj2 না
// // বরং আমরা চাই এখানে Obj1কে ইন্ডিকেট করুক তাহলে এভাবে call মেথড ইউজ করে বলে দিতে পারিঃ
// //এখন এখানে thisআমাদের কথামতো যাতে Obj1 কেই ইন্ডিকেট করে সেটা call মেথড ইউজ করে বলে দিবোঃ
// obj1.obj2.fn.call(obj1);
// // call, bind, applyএই মেথডগুলো শুধুমাত্র ফাংশনের সাথে ইউজ করা যায় যেমনটা আমরা উদাহরণটায় করেছি।
// //  অন্য কোনো ডাটা টাইপ যেমন অবজেক্ট, স্ট্রিং, নাম্বার বা বুলিয়ানের সাথে ইউজ করা যাবে না।





