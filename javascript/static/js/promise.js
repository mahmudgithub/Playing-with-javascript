//প্রমিস (Promise)**********************************************
//জাভাস্ক্রিপ্ট এর অ্যাসিনক্রোনাস আচরণ সম্পর্কে আমরা জানি। রিমোট কোনো সার্ভার থেকে বা 
//একটু সময় লাগে এমন কোনো অপারেশন শেষ করার জন্যে জাভাস্ক্রিপ্ট অপেক্ষা না করে 
//বরং পরের অপারেশনে চলে যায়। এধরনের অপারেশন হচ্ছে অ্যাসিনক্রোনাস অপারেশন। 
//এখন এই অপারেশন ফেলে অন্য অপারেশনে চলে গেলেও জাভাস্ক্রিপ্ট ঠিকই এটাকেও ট্র্যাক করে রাখে। 
//আর এইজন্যেই জাভাস্ক্রিপ্ট প্রমিস(Promise) ব্যবহার করে।
//এখন প্রমিসের কাজ হচ্ছে এ ধরনের অ্যাসিনক্রোনাস অপারেশনকে হ্যান্ডল করা।
//এখন আমরা রিমোট একটা সার্ভারের উপর অপারেশন চালাচ্ছি, কিন্তু ডাটা না আসা পর্যন্ত কিন্তু আমরা বলতে পারি না 
//অপারেশন সফল হবে না বিফলে যাবে। আর মূলত এইসব হ্যান্ডল করার জন্যেই প্রমিস কাজ করে।
// অধিকাংশ ক্ষেত্রেই আমাদের প্রমিস নিজেদের তৈরী করতে হয় না। আমরা জাস্ট প্রমিসটা হ্যান্ডল করি।
// প্রমিসের মূল স্ট্রাকচার আমরা যে লাইব্রেরী দিয়ে কাজ করবো, সিস্টেম থেকে করবো, সেখানেই ইমপ্লিমেন্ট করা থাকে।
// আমাদের জাস্ট প্রমিসটাকে হ্যান্ডল করতে হয়।




// //প্রমিস কিভাবে আমরা নিজেরা তৈরী করতে পারি ************************
// // প্রমিসের মূলত ৩টা স্টেট আছেঃ

// const veri=lol=>{return new Promise((resolve,reject)=>{setTimeout(() => { if(lol){resolve();}else{reject();}   
// },5000);})}
// //এখানে আমরা একটা ফাংশন sos তৈরী করেছি, যেটার একটা আর্গুমেন্ট নিবে। এখন এই ফাংশন প্রমিস রিটার্ণ করবে। 
// //প্রমিস দুইটা আর্গুমেন্ট নেয়, resolveআর reject। তারপর আমরা ভিতরে setTimeoutদিয়ে
// // একটা ফেইক টাইম লাগতে পারে এমন অপারেশন তৈরী করেছি ৩০০০ মিলিসেকেন্ড(৩ সেকেন্ড) টাইম দিয়ে। 
// // তারপর আসলে মজার ব্যাপার। আমাদের প্রমিস যদি তখনি সফল হবে যদি আমরা আমাদের কাঙ্খিত ফলাফল পাই। 
// // এখন আমরা এই ফাংশনে(aPromise) একটা আর্গুমেন্ট নিয়েছি, এটা দিয়ে আমরা trueঅথবা falseপাস করে
// //  প্রমিস সফল না ব্যর্থ সেরকম একটা কন্ডিশন তৈরী করবো। যদি আর্গুমেন্ট টা trueহয় তাহলে আমাদের 
// //  প্রমিস সফল হয়েছে এবং আমরা resolve()কল করবো। আর যদি falseহয় তাহলে reject()কল করার মাধ্যমে 
// //  প্রমিস ব্যর্থ হয়ে
// //এখন আমরা আমাদের ফাংশনটা lol , true আর্গুমেন্ট দিয়ে কল করলেঃ
// lol(true)





// প্রমিস হ্যান্ডল করা *******************************
// // first create a promise
// const vari=pol=>{return new Promise((resolve,reject)=>{setTimeout(() => {if(pol){resolve();}else{reject();}    
// }, 3000)})}
// // এখন আমরা প্রমিস সফল বা ব্যর্থ হয়েছে কিনা সেটা হ্যান্ডল করবো। সেক্ষেত্রে যদি প্রমিস সফল হয় তাহলে 
// // আমাদের lol ফাংশনের সাথে .then()চেইন করে এখানে একটা কলব্যাক ফাংশন দিতে পারবো,
// //  যেটা প্রমিসে সফল বা অন্যকথায় resolveহলে রান হবেঃ
// //আর যদি প্রমিস রিজেক্ট হয় তাহলে আমাদের সেটা আরেকটা চেইন অপারেশন .catch()এর মধ্যে কলব্যাক ফাংশন
// // দিয়ে হ্যান্ডল করতে হবে। এখন আমরা কিন্তু জানিনা যে অপারেশন সফল না ব্যর্থ হবে। সেক্ষেত্রে আমাদের .then()
// //আর .catch()দুইটাই রাখতে হবে। .catch()রান করবে কোনো কারণে যদি আমাদের প্রমিস rejectহয়ঃ
// // call the promise
// vari(true)  // or vari(false)
// // handel the promise(if get date true )
// .then(()=>{console.log('found data');})
// //handel the promise (if get data error )
// .catch(()=>{console.log('not found data');})






// // remote data get by promise******************************
// //এখানে প্রথমে আমরা যে aPromiseফাংশন দিয়ে প্রমিস রিটার্ণ করলাম, সেই প্রমিস তৈরী করার পার্টটা 
// // বেশীরভাগ ক্ষেত্রেই আমাদের লেখা লাগে না। বরং আমরা যে সিস্টেম ব্যবহার করে ডাটা আদান-প্রদান করি,
// //  বা লাইব্রেরী ব্যবহার করি সেগুলোতেই এই অংশটা কোড করা থাকে কখন কিভাবে প্রমিস resolveকরবে 
// //  নাকি rejectকরবে এসব। আমাদের বেশীর ভাগ ক্ষেত্রে রিটার্ণ হওয়া প্রমিস .then()আর .catch()দিয়েই 
// //  হ্যান্ডল করতে হয়। আবার ভিতরে যে কলব্যাক গুলো ব্যবহার করা হয়, সেসব কলব্যাকে বেশীরভাগ ক্ষেত্রে
// //   আমাদের রিমোট সার্ভার থেকে যে ডাটা চাই, সেগুলো আর্গুমেন্ট হিসেবে আসে। আমরা কলব্যাকের ভিতর থেকে
// //    সেই আর্গুমেন্ট এর সাহায্যে সেগুলো অ্যাক্সেস করতে পারি। যেমন আগের প্রমিসটা একটু মডিফাই করলে, 
// //    আমরা চাইলে resolve()বা reject()থেকে ডাটা পাঠাতে পারিঃ
////এখানে resolve()বা reject()থেকে ঠিক যেভাবে ডাটাগুলো পাঠানো হয়েছে সেভাবেই 
////আমরা .then()বা .catch()এর কলব্যাক থেকে অ্যাক্সেস করতে পারবো আর্গুমেন্ট হিসেবে অ্যাক্সেপ্ট করেঃ
// const vari=lol=>{return new Promise((resolve,reject)=>{setTimeout(() => {if(lol){resolve('successfuly data achived')}else{reject('donot achived data')}
// }, 5000);})}
//vari(true).then((data)=>{console.log(data);}).catch((err)=>{console.log(err);})
//OR
// vari(false).then((data)=>{console.log(data);}).catch((err)=>{console.log(err);})









// //a full promise sturucture
// const veri=lol=>{return new Promise((resolve,reject)=>{setTimeout(() => { if(lol){resolve();}else{reject();}   
// },5000);})}
// //if not use setTimeou function
// const four=lol=>{return new Promise((resolve,reject)=>{if(lol){resolve();}else{reject();}})}




// let firstpromise=new Promise((one,two)=>{
//     let city='raj'
//     setTimeout(()=>one (city),5000)    
// })
// firstpromise
// .then((city)=>{

//     console.log('my city  '+  city);
// })
// .catch((error)=>{

// })


// const aPromise = control => { return new Promise((resolve, reject) => {
// setTimeout(() => {if(control) {resolve();} else {reject();}}, 3000)})}
//  aPromise(false)
// .then(() => {
//     console.log('This is a Success');
//  })
//  .catch(() => {
//     console.log('This is a Failure');
//  })


// multiple promise handeling**********************************
//একাধিক প্রমিস হ্যান্ডল করাঃ এরকম কোনো কোনো সময় আমাদের একাধিক প্রমসিও হ্যান্ডল করতে হতে পারে।
// যেমন ধরি আমাদের দুইটা প্রমিস আছেঃ lol1 and lol2
//const lol1=new Promise((resolve,reject)=>{
//setTimeout(()=>{if (true){resolve('lol1 success');} else{reject('lol1 error');}},3000)});

//const lol2=new Promise((resolve,reject)=>{
//setTimeout(()=>{if (true){resolve('lol2 success');} else{reject('lol2 errro');}},3000)});

//এখন এই দুইটা প্রমিস কমপ্লিট হওয়ার পর কোনো অপারেশন চালাতে চাইলে আমরা দুইটা প্রমিসকে অ্যারে আকারে এভাবে নিতে পারিঃ তারপর 
//.then()দিয়ে কলব্যাক কল করতে পারবো যেটা এই দুইটা প্রমিস কমপ্লিট হলে পরেই রান করবে। আর এই প্রমিসগুলো থেকে আসা ডাটাগুলো 
//এই কলব্যাক ফাংশনে অ্যারে আকারে আসবেঃ
//Promise.all([lol1,lol2]).then((dataArr)=>{console.log(dataArr);}).catch((errorArr)=>{console.log(errorArr);})
